---
layout: post
title: "Intent"
date: 2018-07-26 18:48:00 -0500
tags: [tumblr-archive]
---

One of the challenges of designings good system, and writing good code in general,
is deciding where and when to draw boundaries. Boundaries can be drawn in many
ways - deciding to extract something to a class is a form of boundary drawing,
as is extracting a method from a conditional. Modules and microservices are
the same - just chalk outlines around a piece of functionality that delineates
which parts get to hang out together.

Getting good at figuring out the boundaries is no small task - however, even
when you have a sense of the approximate line, there are details that require
significant thought. One of these areas is when to remove duplication for the
sake of cleaner lines. I’ll give an example:

Some fairly straightforward code.enterScreenis called at some point by
some code, and when doing so, it decides based on some condition whether to
callgoFromToporgoFromBottom. Now, there is a bit of duplication here -
theaddClassmethod is called twice, with the same class. For the sake of
a simple argument, let us assume that this class will always be the same.

What should we do here? Is this code good? Well, while the answer to the latter
is certainly subjective, there is a case to be made for answering the former
with: “let’s remove the duplication - remove those methods and do this:”

Now, this doesn’t break any hard ‘rules’ - we can still easily test this method,
and it’s short enough that it’s clear what’s happening. In addition, it saves
us some lines - if we have a ton of code, this might save us a decent chunk
of bytes, even in the minified code. However, I think this method is a mistake,
as it causes a broader, if less obvious problem.

The second code snipper has fuzzier boundaries. In the first snippet, we have
drawn a line around our condition -isTop, and made a very declarative
statement about what comes after - either we translate something from the
bottom, or we translate it from the top. These 'lines’ are delineations not
only in our code organization, but in our verbiage about what the code expressly
does. We are marking, very clearly, what the line around 'translate from the
bottom’ and 'translate from the top’ means. While we are repeating some code,
we are clarifying what we consider the boundary - the space between the
condition and the code.

In our second snipper, we have made this boundary a bit fuzzier. While we still
have an obvious condition - isTop, and it’s clear to us what we should do in
each case, we don’t have a clear understanding of what happens if this code
changes. We also don’t have a clear understanding as to what isimportantin
this code. We have been told (mostly) that what is important is that we are
entering the screen, and that we have a condition - however, the details are
not important. In the former case, we are building a fence around each part
of that condition, making it clear that we think each piece is separate and
important enough to be given its own chalk outline.

This may seem pendantic, but I think it’s a decision that, over time, leads to
generally better code. While there are certainly areas where you may want tonotdraw a line around a condition, in my experience most code bases would
benefit greatly from that line. All code grows and evolves, but conditionals
are where it decays. Drawing thick outlines keeps that decay from spreading -
it makes sure that a maintainer of the code is very clear about the
intentionality behing the code, not just what’s written on the lines.

There are downsides - if you have a large codebase, this could eventually
balloon it significantly. If you’re not careful, you could end up with a lot
of duplication before it’s obvious that there are components that are capable of
reuse. However, I trust in Sandi Metz’s famous mantra - “prefer duplication over
the wrong abstraction”. It will save your ass in the long run.