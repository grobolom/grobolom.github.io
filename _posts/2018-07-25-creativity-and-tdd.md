---
layout: post
title: "Creativity and TDD"
date: 2018-07-25 06:51:00 -0500
---

One of the challenges of creativity in programming is being unable to explore code in a way that one explores other forms of art.

If you are a painter with a blank canvas, you have many ways of playing around
with your paint and your brushes and your pallette to form something you’ve
never touched before. You can experiment with changing the angles you use,
or painting in a different light, or using a new set of colors or textures.
With code, this experimentation sometimes feels out of reach. You can grab
a new set of brushes (a new programming language) or a new set of paints (a
new type of pattern you’ve learned) but it’s often hard to come up with a new
picture. It often feels like you’re coloring by number, only varying the colors.

I think test-driven-development is an answer to this challenge of creativity.
In particular, London-style TDD is one of the most freeing and though-provoking
exercises I’ve done in programming over the last few years.

Being able to define the forms and shapes of your code before writing it allows
you to pull away from pushing blocks of color together and step out into the
outline. By outlining the structure of your code first, you can play with what
shape it should eventually take. Like molding clay, this shaping allows you to
play with what the final product will be before baking anything. It allows you
to go far into the absurd with you APIs, describing and defining them without
stepping even a bit into the code itself.

This comes with other benefits, as well. By building these shapes and structures
ahead of the final product, you can develop more robust code as well. It’s
easier to see where the snags and challenges will be when you are building
the floor those snags will stick out of. It means you can tell when you are
doing something wrong, because when writing out the tests you’ll be writing
code thatfeelsodd, rather than just looks it afterwards.

Now, all of this is not to say that TDD is the solution to all problems of
creativity in software. Code requires a large set of tools to be done well, and
learning those tools and understanding them in a way that allows you to
experiment quickly without getting stuck in the details is no easy ask. But it
is possible, and earning the skill needed to do so is rewarding on its own as
well.